package com.demo.highConcurrency;

/**
 * @author LiHaitao
 * @description CasArithmetic:Cas（Compare and Swap)算法:比较再交换
 * @date 2019/9/23 13:14
 **/
public class CasArithmetic {
    /**1，悲观锁和乐观锁：
     * 悲观锁：总是假设最坏的情况，认为竞争总是存在，每次拿数据的时候都认为会被修改，因此每次都会先上锁。其他线程阻塞等待释放锁。
     * 乐观锁：总是假设最好的情况，认为竞争总是不存在，每次拿数据的时候都认为不会被修改，因此不会先上锁，在最后更新的时候比较数据有无更新，
     * 可通过版本号或CAS实现。
     * 2，使用场景：
     * 悲观锁：用于写比较多的情况，避免了乐观锁不断重试从而降低性能
     * 乐观锁: 用于读比较多的情况避免了不必要的加锁的开销
     *
     * 3，Cas算法：
     * jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronized同步锁的一种乐观锁。
     * JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。
     * 4，Cas理解：
     * Cas是一种无锁算法，Cas有三个操作数，内存值V，旧的预期值A，需要修改的新值B，
     * 当且仅当预期值A和内存值V相同时，将内存值修改为B，否则什么都不做。
     * Cas操作是基于共享数据不会被修改的情况下（假设两个线程t1，t2共同修改一个变量值value=1001,线程发生竞争，t1成功竞争修改了value
     * 为1002，而t2则会失败，因为t1改变了value为1002，与预期值不相等）。
     * CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。
     * 5，CAS存在的问题：
     * 1，ABA问题（线程1准备用CAS将变量的值由A替换为C，在此之前，线程2将变量的值由A替换为B，又由B替换为A，然后线程1执行CAS时发现变量的值仍然为A，所以CAS成功。但实际上这时的现场已经和最初不同了，尽管CAS成功，但可能存在潜藏的问题。）
     * 2，循环时间长开销大
     * 3，只能保证一个共享变量的原子操作
     *
     *
     *
     *
     *
     *
     *
     *
     *
     *
     */
}
